# 粘包处理完整图示文档

## 🎯 什么是粘包？

**粘包**：TCP是流式传输，多条消息可能在一次接收中被合并成一个数据块，导致消息边界不清晰。

## 📊 粘包问题图示

### 正常情况（理想）

```
发送：消息1[长度:10][数据10] + 消息2[长度:15][数据15]
接收：消息1 → 消息2（分开接收）
```

### 粘包情况（实际可能发生）

```
发送：消息1[长度:10][数据10] + 消息2[长度:15][数据15]
接收缓冲区：[长度10][数据10][长度15][数据15]全部粘在一起
```

## 🔍 核心代码解析

### 完整代码

```cpp
void Server::readClientData()
{
    QTcpSocket *client = qobject_cast<QTcpSocket*>(sender());
    if (!client) return;

    QDataStream in(client);
    in.setVersion(QDataStream::Qt_6_0);

    static QMap<QTcpSocket*, quint32> packetSizes;

    while (true) {  // ⭐ 关键1：循环处理多条消息
        // ⭐ 关键2：检查是否已读取长度
        if (packetSizes[client] == 0) {
            // ⭐ 关键3：检查长度字段是否完整
            if (client->bytesAvailable() < sizeof(quint32)) {
                break; // 长度字段都不完整，等待
            }
            // ⭐ 关键4：读取长度前缀
            in >> packetSizes[client];
        }

        // ⭐ 关键5：检查数据是否完整
        if (client->bytesAvailable() < packetSizes[client]) {
            break; // 数据不完整，等待
        }

        // ⭐ 关键6：读取完整数据
        QByteArray jsonData = client->read(packetSizes[client]);
        packetSizes[client] = 0; // 重置

        // 解析并处理
        QJsonParseError error;
        QJsonDocument doc = QJsonDocument::fromJson(jsonData, &error);

        if (error.error == QJsonParseError::NoError && doc.isObject()) {
            handleMessage(client, doc.object());
        }
    }
}
```

## 🎬 执行场景示例

### 场景1：正常情况（单条消息）

```
发送端发送：
[长度:4字节=10][JSON数据:10字节]

接收端执行：
1. 读取长度：10
2. 检查数据：10字节完整
3. 读取10字节数据
4. 处理消息
5. 继续循环，发现没有更多数据，退出
```

### 场景2：粘包情况（两条消息粘在一起）

```
发送端发送：
消息1：[长度:10][数据10] + 消息2：[长度:15][数据15]

接收缓冲区：
[长度10][数据10][长度15][数据15]  ← 全部粘在一起，共39字节

执行过程：

第一次循环：
1. 读取长度：10
2. 检查数据：10字节完整
3. 读取10字节（消息1）
4. 处理消息1
5. 重置状态

第二次循环：
1. 读取长度：15
2. 检查数据：15字节完整
3. 读取15字节（消息2）
4. 处理消息2
5. 重置状态

第三次循环：
1. 检查长度字段：0字节，不够4字节
2. break退出循环

✅ 完美处理了粘包！
```

### 场景3：半包情况（数据不完整）

```
发送端发送：
[长度:100][JSON数据:100字节]

接收端第一次接收：
[长度:100][JSON数据:30字节]  ← 只收到部分数据

执行过程：

第一次调用：
1. 读取长度：100
2. 检查数据：30 < 100？是！
3. break退出，等待更多数据
4. packetSizes[client] = 100（static保存）

第二次调用（剩余数据到达）：
1. packetSizes[client] = 100（还记得）
2. 检查数据：100字节完整
3. 读取100字节
4. 处理消息

✅ 完美处理了半包！
```

## 📊 关键设计点图示

### 1. while(true) 循环的作用

```
┌─────────────────────────────────────────┐
│  数据到达 readClientData() 触发         │
└─────────────────┬───────────────────────┘
                  │
        ┌─────────▼──────────┐
        │  while(true) 循环  │
        └─────────┬──────────┘
                  │
        ┌─────────▼──────────┐
        │  处理第一条消息     │
        └─────────┬──────────┘
                  │
        ┌─────────▼──────────┐
        │  还有更多数据？     │
        └─────────┬──────────┘
             是   │   否
        ┌─────────▼──────────┐
        │  继续循环          │
        │  处理第二条消息     │
        └────────────────────┘
```

### 2. 状态保存机制

```
static QMap<QTcpSocket*, quint32> packetSizes;

第一次调用：
packetSizes[client1] = 100  ← 保存长度

第二次调用（数据还没完整）：
packetSizes[client1] = 100  ← 还记得需要100字节

第三次调用（数据完整）：
读取100字节
packetSizes[client1] = 0    ← 重置，准备下一条
```

### 3. 数据完整性检查

```
检查流程：
┌─────────────────────┐
│  bytesAvailable()   │ 当前缓冲区有多少字节？
└──────────┬──────────┘
           │
           ▼
┌─────────────────────┐
│  packetSizes[client]│ 需要多少字节？
└──────────┬──────────┘
           │
           ▼
    当前 >= 需要？
      │      │
    是│      │否
      │      │
      ▼      ▼
   读取数据  等待
```

## 💡 关键理解点

### 1. 为什么需要循环？

**问题**：一次接收可能包含多条消息

**解决**：使用 `while(true)` 循环，处理完一条消息后继续处理下一条

### 2. 为什么需要检查完整性？

**问题**：TCP可能分多次发送，数据不完整

**解决**：检查 `bytesAvailable() >= packetSizes[client]`，不够就等待

### 3. 为什么需要保存状态？

**问题**：数据分多次到达，需要记住读取到哪一步

**解决**：使用 `static QMap` 保存每个客户端的状态

### 4. 为什么需要重置状态？

**问题**：处理完一条消息后，需要准备读取下一条

**解决**：`packetSizes[client] = 0`，标记为"未读取长度"

## 🎯 总结

### 粘包处理的5个关键点

1. ✅ **循环处理**：`while(true)` - 处理多条粘包消息
2. ✅ **检查长度完整性**：读取长度前检查是否有4字节
3. ✅ **检查数据完整性**：读取数据前检查数据是否够
4. ✅ **状态保存**：为每个客户端保存当前读取状态
5. ✅ **等待机制**：数据不够时 `break` 退出，等待更多数据

### 完整工作流程

```
数据到达
   ↓
检查长度字段是否完整？
   ├─ 否 → break (等待更多数据) ← 处理半包
   └─ 是 → 读取长度值
         ↓
      检查数据是否完整？
         ├─ 否 → break (等待更多数据) ← 处理半包
         └─ 是 → 读取完整数据
               ↓
            解析处理消息
               ↓
            重置状态
               ↓
            还有数据？→ 继续循环 ← 处理粘包
               └─ 无 → 退出
```

### 代码位置

- **定义**：`server.cpp` 第 111-143 行
- **调用**：当客户端发送数据时，Qt框架自动调用

**这个实现完美解决了TCP的粘包和半包问题！**

