# 长度前缀完整图示文档

## 🎯 核心答案

**`packetSizes[client]` 不是提前知道的，而是从消息头部先读取的！**

## 📦 消息的完整格式

### 发送端构造的消息

```
发送端发送的完整消息：
┌─────────────────────────────────────┐
│  第1部分：长度前缀（4字节）          │
│  [0x00][0x00][0x00][0x64]           │
│  表示：这个消息有 100 字节的数据     │
├─────────────────────────────────────┤
│  第2部分：实际JSON数据（100字节）    │
│  {"type":1002,"success":true,...}   │
└─────────────────────────────────────┘
        总共：104字节
```

### 发送端代码

```cpp
// 第61行：先写入长度
stream << (quint32)jsonData.size();  
// 如果 jsonData.size() = 100
// 就写入：0x00 0x00 0x00 0x64（表示100）

// 第62行：再追加实际数据
packet.append(jsonData);
// 追加100字节的JSON数据

// 第64行：发送完整数据包
client->write(packet);
// 发送：4字节长度 + 100字节数据 = 104字节
```

## 📥 接收端读取过程

### TCP流式传输的特点

TCP是流式的，数据可能这样到达：

```
第一次到达：4字节（长度前缀）
[0x00][0x00][0x00][0x64]

第二次到达：30字节（数据的一部分）
[{"type":1002,"success":true...]

第三次到达：70字节（数据的剩余部分）
[..."message":"登录成功"...]
```

### 接收端代码的执行过程

#### 第一步：读取长度前缀

```cpp
// 第78行：检查是否已经读取过长度
if (packetSizes[client] == 0) {
    // ✓ 是0，说明还没读取过长度
    
    // 第79行：检查长度字段是否完整
    if (client->bytesAvailable() < sizeof(quint32)) {
        // 如果可读字节数 < 4，说明长度字段都没完整
        break; // 退出，等待更多数据
    }
    
    // 第82行：⭐ 关键！先读取前4字节（长度前缀）
    in >> packetSizes[client];
    // 从socket读取4字节：0x00 0x00 0x00 0x64
    // 转换为 quint32：100
    // 保存到 packetSizes[client] = 100
    // 现在知道了：需要等待100字节的数据！
}
```

**此时的状态**：
```
packetSizes[client] = 100  ← 从长度前缀读取到的
TCP缓冲区剩余：0字节（长度已读走）
```

#### 第二步：检查数据是否完整

```cpp
// 第85行：检查实际数据是否完整
if (client->bytesAvailable() < packetSizes[client]) {
    // bytesAvailable() = 当前缓冲区有多少字节
    // packetSizes[client] = 100（从长度前缀读到的）
    
    // 如果当前字节数 < 100，说明数据还没收全
    break; // 退出，等待更多数据
}
```

**情况A：数据不完整**
```
TCP缓冲区：[30字节的JSON数据]
bytesAvailable() = 30
packetSizes[client] = 100

检查：30 < 100？ 是！
执行：break（退出等待）
```

**情况B：数据完整**
```
TCP缓冲区：[100字节的JSON数据]
bytesAvailable() = 100
packetSizes[client] = 100

检查：100 < 100？ 否！
继续执行：读取数据
```

#### 第三步：读取完整数据

```cpp
// 第89行：读取完整的数据
QByteArray jsonData = client->read(packetSizes[client]);
// 使用之前保存的长度值（100）来读取
// 读取100字节的JSON数据
```

## 🎬 完整时序图

```
时间轴：       发送端                    网络               接收端
─────────────────────────────────────────────────────────────

t1:     构造消息
        [长度:100][数据:100字节]
        ↓
        ┌─────────────────────────────────┐
        │ 发送：104字节                    │
        └─────────────────────────────────┘
                 │
                 ↓
        [长度:4字节] 先到达
                 │
                 ↓
                                 第一次调用readClientData()
                                 ↓
                                 读取长度：100
                                 packetSizes[client] = 100
                                 ↓
                                 检查数据：0 < 100？
                                 是！break（退出等待）

t2:                                        │
                                           │
        [数据:30字节] 到达                 │
                 │                         │
                 ↓                         ↓
                                 第二次调用readClientData()
                                 ↓
                                 packetSizes[client] = 100（static保存）
                                 检查数据：30 < 100？
                                 是！break（继续等待）

t3:                                        │
                                           │
        [数据:70字节] 到达                 │
                 │                         │
                 ↓                         ↓
                                 第三次调用readClientData()
                                 ↓
                                 packetSizes[client] = 100
                                 检查数据：100 < 100？
                                 否！读取100字节
                                 ↓
                                 处理消息
                                 重置状态
```

## 💡 关键理解

### 1. 长度前缀是协议的一部分

```
我们的应用层协议格式：
┌──────────┬──────────┐
│ 长度字段  │ 数据字段  │
│ 4字节    │ N字节    │
│ (100)    │ (100字节)│
└──────────┴──────────┘
```

这不是TCP提供的，而是**我们定义的协议格式**！

### 2. 两步读取

```
第一步：读取长度字段（4字节）
   ↓
得到：需要等待100字节
   ↓
保存到：packetSizes[client] = 100
   ↓
第二步：检查数据是否完整
   ↓
bytesAvailable() >= 100？
   ↓
是 → 读取100字节
否 → 等待更多数据
```

### 3. static变量的作用

```cpp
static QMap<QTcpSocket*, quint32> packetSizes;
```

- **第一次调用**：读取长度前缀，保存到 `packetSizes[client] = 100`
- **第二次调用**：即使数据还没完整，还记得需要等待100字节
- **第三次调用**：数据完整了，使用保存的长度值读取

## 🔍 常见误解

### ❌ 误解1：提前知道数据大小

```
错误理解：程序提前知道数据有100字节

正确理解：程序先读取长度前缀（4字节），
         从长度前缀中得到100这个数字，
         然后根据这个数字等待数据
```

### ❌ 误解2：TCP提供了数据大小信息

```
错误理解：TCP告诉程序数据有多少字节

正确理解：TCP是流式的，不提供边界信息。
         我们自己在数据前面加了长度字段（协议设计），
         程序读取这个长度字段，才知道数据大小
```

### ❌ 误解3：一次性收到所有数据

```
错误理解：TCP一次性发送104字节，一次性收到

正确理解：TCP可能分多次发送，分多次到达。
         可能先到4字节（长度），后到100字节（数据）
         或者先到4字节，再30字节，再70字节
```

## ✅ 正确理解

### 协议设计思路

```
问题：TCP是流式的，没有消息边界
解决：自己设计协议格式

我们的协议：
┌────────────┬────────────┐
│ 长度前缀    │ 实际数据    │
│ 告诉接收端  │ 接收端根据   │
│ 要等多少字节│ 长度读取     │
└────────────┴────────────┘
```

### 读取流程

```
1. 先读取长度前缀（4字节）
   → 得到数字：100
   → 保存：packetSizes[client] = 100
   
2. 根据长度值检查数据
   → 当前有多少字节？
   → 够100字节了吗？
   → 不够：退出等待
   → 够了：读取100字节
```

## 🎯 总结

**答案**：

1. **TCP确实是流式传输**，数据逐步到达
2. **但我们设计了协议格式**：每条消息 = [长度前缀4字节] + [实际数据N字节]
3. **接收端先读取长度前缀**，得到需要等待的字节数（比如100）
4. **保存这个数字**到 `packetSizes[client] = 100`
5. **然后根据这个数字**，检查数据是否完整

**关键代码位置**：

```cpp
// 第82行：从消息头部读取长度
in >> packetSizes[client];  // 读取4字节长度前缀，得到100

// 第85行：根据读取到的长度，检查数据完整性
if (client->bytesAvailable() < packetSizes[client]) {
    // bytesAvailable() = 当前缓冲区有多少字节
    // packetSizes[client] = 100（从长度前缀读到的）
    break; // 不够就等待
}
```

**所以，不是提前知道，而是先从消息头部读取长度，然后再等待对应大小的数据！**

